
%extra_argument { struct Command *command }
%token_prefix tk

%token_type {uint32_t}
%include {
#include <stdbool.h> 
#include <stdint.h>
#include <string.h>
#include "commands.h"

#ifdef __cplusplus
extern "C" {
#endif

uint32_t cpuGetSR();
uint32_t cpuGetPC();
uint32_t cpuGetAReg(unsigned);
uint32_t cpuGetDReg(unsigned);
uint32_t debuggerReadLong(uint32_t);

#ifdef __cplusplus
}
#endif


#undef NDEBUG

}

%parse_failure {
	fprintf(stderr,"I don't understand.\n");
	command->valid = false;
}

%parse_accept {
	command->valid = true;
}



%left PIPEPIPE.
%left AMPAMP.
%left PIPE.
%left CARET.
%left AMP.
%left EQEQ BANGEQ.
%left LT LTEQ GT GTEQ.  
%left LTLT GTGT.
%left PLUS MINUS. 
%left STAR SLASH PERCENT.
%right BANG TILDE.


stmt ::= expr(a) EOL.
{
	command->action = Print;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= PRINT expr(a) EOL.
{
	command->action = Print;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= BREAK expr(a) EOL.
{
	command->action = Break;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= CONTINUE EOL.
{
	command->action = Continue;
	command->argc = 0;
}

stmt ::= TBREAK expr(a) EOL.
{
	// negative number = remove it.
	command->action = TBreak;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= NEXT EOL.
{
	command->action = Step;
	command->argc = 0;
}

stmt ::= NEXT expr(a) EOL.
{
	command->action = Step;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= DUMP expr(a) EOL.
{
	command->action = Dump;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= LIST expr(a) EOL.
{
	command->action = List;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= expr(a) SEMIL EOL.
{
	command->action = List;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= expr(a) SEMIH EOL.
{
	command->action = Dump;
	command->argc = 1;
	command->argv[0] = a;
}


stmt ::= DREGISTER(a) EQ expr(b) EOL.
{
	command->action = SetDRegister;
	command->argc = 2;
	command->argv[0] = a;
	command->argv[1] = b;
}

stmt ::= AREGISTER(a) EQ expr(b) EOL.
{
	command->action = SetARegister;
	command->argc = 2;
	command->argv[0] = a;
	command->argv[1] = b;
}

stmt ::= XREGISTER(a) EQ expr(b) EOL.
{
	command->action = SetXRegister;
	command->argc = 2;
	command->argv[0] = a;
	command->argv[1] = b;
}

stmt ::= HELP EOL.
{
	command->action = Help;
	command->argc = 0;
}

expr(rhs) ::= unary(a). { rhs = a; }
expr(rhs) ::= expr(a) PLUS expr(b). { rhs = a + b; }
expr(rhs) ::= expr(a) MINUS expr(b). { rhs = a - b; }
expr(rhs) ::= expr(a) STAR expr(b). { rhs = a * b; }
expr(rhs) ::= expr(a) SLASH expr(b). { rhs = a / b; }
expr(rhs) ::= expr(a) PERCENT expr(b). { rhs = a % b; }
expr(rhs) ::= expr(a) LTLT expr(b). { rhs = a << b; }
expr(rhs) ::= expr(a) GTGT expr(b). { rhs = a >> b; }
expr(rhs) ::= expr(a) LT expr(b). { rhs = a < b; }
expr(rhs) ::= expr(a) LTEQ expr(b). { rhs = a <= b; }
expr(rhs) ::= expr(a) GT expr(b). { rhs = a > b; }
expr(rhs) ::= expr(a) GTEQ expr(b). { rhs = a >= b; }
expr(rhs) ::= expr(a) EQEQ expr(b). { rhs = a == b; }
expr(rhs) ::= expr(a) BANGEQ expr(b). { rhs = a != b; }
expr(rhs) ::= expr(a) AMP expr(b). { rhs = a & b; }
expr(rhs) ::= expr(a) CARET expr(b). { rhs = a ^ b; }
expr(rhs) ::= expr(a) PIPE expr(b). { rhs = a | b; }
expr(rhs) ::= expr(a) AMPAMP expr(b). { rhs = a && b; }
expr(rhs) ::= expr(a) PIPEPIPE expr(b). { rhs = a || b; }


unary(rhs) ::= term(a). { rhs = a; }
unary(rhs) ::= PLUS unary(a). [BANG] { rhs = a; }
unary(rhs) ::= MINUS unary(a). [BANG] { rhs = -a; }
unary(rhs) ::= TILDE unary(a). { rhs = ~a; }
unary(rhs) ::= BANG unary(a). { rhs = !a; }
unary(rhs) ::= STAR unary(a). [BANG] { rhs = debuggerReadLong(a); }


term(rhs) ::= LPAREN expr(a) RPAREN. { rhs = a; }
term(rhs) ::= INTEGER(a). { rhs = a; }
term(rhs) ::= DREGISTER(a). { rhs = cpuGetDReg(a); }
term(rhs) ::= AREGISTER(a). { rhs = cpuGetAReg(a); }
term(rhs) ::= XREGISTER(a).
{
	switch(a)
	{
	case 0: 
		rhs = cpuGetPC();
		break;
	case 1:
		rhs = cpuGetSR();
		break;
	default:
		rhs = 0;
	}
}
