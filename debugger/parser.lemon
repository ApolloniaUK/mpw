
%extra_argument { struct Command *command }
%token_prefix tk

%token_type {uint32_t}
%include {
#include <stdbool.h> 
#include <stdint.h>
#include <string.h>
#include "commands.h"

uint32_t cpuGetSR();
uint32_t cpuGetPC();
uint32_t cpuGetAReg(unsigned);
uint32_t cpuGetDReg(unsigned);
uint32_t debuggerReadLong(uint32_t);
}

%parse_failure {
	fprintf(stderr,"I don't understand.\n");
	command->valid = false;
}

%parse_accept {
	command->valid = true;
}



%left PIPEPIPE.
%left AMPAMP.
%left PIPE.
%left CARET.
%left AMP.
%left EQEQ BANGEQ.
%left LT LTEQ GT GTEQ.  
%left LTLT GTGT.
%left PLUS MINUS. 
%left STAR SLASH PERCENT.
%right BANG TILDE.


stmt ::= expr(a).
{
/*
	// print the value.
	// hex, base 10, signed 16-bit (if appropriate)
	printf("$%08x - %u", a, a);

	if (a & 0x80000000)
		printf(" %d", (int32_t)a);

	if ((a & 0xffff8000) == 0x8000)
		printf(" %h", (int16_t)a);

	printf("\n");
*/
	command->action = Print;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= BREAK expr(a).
{
	command->action = Break;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= CONTINUE.
{
	command->action = Continue;
	command->argc = 0;
}

stmt ::= TBREAK expr(a).
{
	// negative number = remove it.
	command->action = TBreak;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= NEXT.
{
	command->action = Step;
	command->argc = 0;
}

stmt ::= NEXT expr(a).
{
	command->action = Step;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= PRINT expr(a).
{
	command->action = Print;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= DUMP expr(a).
{
	command->action = Dump;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= LIST expr(a).
{
	command->action = List;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= expr(a) SEMIL.
{
	command->action = List;
	command->argc = 1;
	command->argv[0] = a;
}

stmt ::= expr(a) SEMIH.
{
	command->action = Dump;
	command->argc = 1;
	command->argv[0] = a;
}


stmt ::= DREGISTER(a) EQ expr(b).
{
	command->action = SetDRegister;
	command->argc = 2;
	command->argv[0] = a;
	command->argv[1] = b;
}

stmt ::= AREGISTER(a) EQ expr(b).
{
	command->action = SetARegister;
	command->argc = 2;
	command->argv[0] = a;
	command->argv[1] = b;
}

stmt ::= XREGISTER(a) EQ expr(b).
{
	command->action = SetXRegister;
	command->argc = 2;
	command->argv[0] = a;
	command->argv[1] = b;
}

stmt ::= HELP .
{
	command->action = Help;
	command->argc = 0;
}

expr(rhs) ::= unary(a). { rhs = a; }
expr(rhs) ::= term(a) PLUS term(b). { rhs = a + b; }
expr(rhs) ::= term(a) MINUS term(b). { rhs = a + b; }
expr(rhs) ::= term(a) STAR term(b). { rhs = a * b; }
expr(rhs) ::= term(a) SLASH term(b). { rhs = a / b; }
expr(rhs) ::= term(a) PERCENT term(b). { rhs = a % b; }
expr(rhs) ::= term(a) LTLT term(b). { rhs = a << b; }
expr(rhs) ::= term(a) GTGT term(b). { rhs = a >> b; }
expr(rhs) ::= term(a) LT term(b). { rhs = a < b; }
expr(rhs) ::= term(a) LTEQ term(b). { rhs = a <= b; }
expr(rhs) ::= term(a) GT term(b). { rhs = a > b; }
expr(rhs) ::= term(a) GTEQ term(b). { rhs = a >= b; }
expr(rhs) ::= term(a) EQEQ term(b). { rhs = a == b; }
expr(rhs) ::= term(a) BANGEQ term(b). { rhs = a != b; }
expr(rhs) ::= term(a) AMP term(b). { rhs = a & b; }
expr(rhs) ::= term(a) CARET term(b). { rhs = a ^ b; }
expr(rhs) ::= term(a) PIPE term(b). { rhs = a | b; }
expr(rhs) ::= term(a) AMPAMP term(b). { rhs = a && b; }
expr(rhs) ::= term(a) PIPEPIPE term(b). { rhs = a || b; }


unary(rhs) ::= term(a). { rhs = a; }
unary(rhs) ::= PLUS unary(a). [BANG] { rhs = a; }
unary(rhs) ::= MINUS unary(a). [BANG] { rhs = -a; }
unary(rhs) ::= TILDE unary(a). { rhs = ~a; }
unary(rhs) ::= BANG unary(a). { rhs = !a; }
unary(rhs) ::= STAR unary(a). [BANG] { rhs = debuggerReadLong(a); }


term(rhs) ::= LPAREN expr(a) RPAREN. { rhs = a; }
term(rhs) ::= INTEGER(a). { rhs = a; }
term(rhs) ::= DREGISTER(a). { rhs = cpuGetDReg(a); }
term(rhs) ::= AREGISTER(a). { rhs = cpuGetAReg(a); }
term(rhs) ::= XREGISTER(a).
{
	switch(a)
	{
	case 0: 
		rhs = cpuGetPC();
		break;
	case 1:
		rhs = cpuGetSR();
		break;
	default:
		rhs = 0;
	}
}
